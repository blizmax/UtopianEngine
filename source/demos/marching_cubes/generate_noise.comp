#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (set = 0, binding = 0, rgba8) uniform writeonly image3D resultImage;

// layout (set = 0, binding = 3) uniform UBO_input
// {
// 	mat4 projection;
// 	mat4 view;
// 	vec4 offsets[8];
// 	vec4 color;
// 	float voxelSize;
// 	float time;
// } ubo;

float sdSphere(vec3 p, float s)
{
  return length(p)-s;
}

float sdTorus(vec3 p, vec2 t)
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

float sdCone(vec3 p, vec2 c)
{
    // c must be normalized
    float q = length(p.xy);
    return dot(c,vec2(q,p.z));
}

float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

//---------------------------------------------------------------
// value noise, and its analytical derivatives
// Reference: https://www.shadertoy.com/view/XttSz2
//---------------------------------------------------------------

float hash( float n ) { return fract(sin(n)*753.5453123); }

vec4 noised( in vec3 x )
{
    vec3 p = floor(x);
    vec3 w = fract(x);
    vec3 u = w*w*(3.0-2.0*w);
    vec3 du = 6.0*w*(1.0-w);
    
    float n = p.x + p.y*157.0 + 113.0*p.z;
    
    float a = hash(n+  0.0);
    float b = hash(n+  1.0);
    float c = hash(n+157.0);
    float d = hash(n+158.0);
    float e = hash(n+113.0);
    float f = hash(n+114.0);
    float g = hash(n+270.0);
    float h = hash(n+271.0);

    float k0 =   a;
    float k1 =   b - a;
    float k2 =   c - a;
    float k3 =   e - a;
    float k4 =   a - b - c + d;
    float k5 =   a - c - e + g;
    float k6 =   a - b - e + f;
    float k7 = - a + b + c - d + e - f - g + h;

    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, 
                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));
}

vec4 fbmd( in vec3 x )
{
    const float scale = 1.5;

    float a = 0.0;
    float b = 0.5;
	float f = 1.0;
    vec3 d = vec3(0.0);
    for( int i=0; i<8; i++ )
    {
        vec4 n = noised(f*x*scale);
        a += b*n.x;           // accumulate values
        d += b*n.yzw*f*scale; // accumulate derivatives
        b *= 0.5;             // amplitude decrease
        f *= 1.8;             // frequency increase
    }

	return vec4( a, d );
}

float density(vec3 pos)
{
	float density = -pos.y;

	//density = max(-noised(pos * 2).x + 0.37, density);
	density = max(-fbmd(pos * 1).x + 0.40, density);

	return density;
}

void main(void)
{
    float density = density(gl_GlobalInvocationID.xyz / 32.0f);
    imageStore(resultImage, ivec3(gl_GlobalInvocationID.xyz), vec4(density));
    //imageStore(resultImage, ivec3(gl_GlobalInvocationID.xyz), vec4(gl_GlobalInvocationID.z / 33.0f));
}