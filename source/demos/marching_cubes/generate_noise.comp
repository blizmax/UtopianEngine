#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable


layout (set = 0, binding = 0, rgba8) uniform writeonly image3D resultImage;

// layout (set = 0, binding = 3) uniform UBO_input
// {
// 	mat4 projection;
// 	mat4 view;
// 	vec4 offsets[8];
// 	vec4 color;
// 	float voxelSize;
// 	float time;
// } ubo;

float sdSphere(vec3 p, float s)
{
  return length(p)-s;
}

float sdTorus(vec3 p, vec2 t)
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

float sdCone(vec3 p, vec2 c)
{
    // c must be normalized
    float q = length(p.xy);
    return dot(c,vec2(q,p.z));
}

float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

float cosNoise(vec2 pos)
{
	float amplitude = 1.0f;
	float freq = 5500.0f;
	return amplitude * (sin(pos.x/freq) + sin(pos.y / freq));
}

const mat2 m2 = mat2(1.6,-1.2,
                     1.2, 1.6);



//---------------------------------------------------------------
// value noise, and its analytical derivatives
// Reference: https://www.shadertoy.com/view/XttSz2
//---------------------------------------------------------------

float hash( float n ) { return fract(sin(n)*753.5453123); }

vec4 noised( in vec3 x )
{
    vec3 p = floor(x);
    vec3 w = fract(x);
    vec3 u = w*w*(3.0-2.0*w);
    vec3 du = 6.0*w*(1.0-w);
    
    float n = p.x + p.y*157.0 + 113.0*p.z;
    
    float a = hash(n+  0.0);
    float b = hash(n+  1.0);
    float c = hash(n+157.0);
    float d = hash(n+158.0);
    float e = hash(n+113.0);
    float f = hash(n+114.0);
    float g = hash(n+270.0);
    float h = hash(n+271.0);

    float k0 =   a;
    float k1 =   b - a;
    float k2 =   c - a;
    float k3 =   e - a;
    float k4 =   a - b - c + d;
    float k5 =   a - c - e + g;
    float k6 =   a - b - e + f;
    float k7 = - a + b + c - d + e - f - g + h;

    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, 
                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));
}

vec4 fbmd( in vec3 x )
{
    const float scale = 1.5;

    float a = 0.0;
    float b = 0.5;
	float f = 1.0;
    vec3 d = vec3(0.0);
    for( int i=0; i<8; i++ )
    {
        vec4 n = noised(f*x*scale);
        a += b*n.x;           // accumulate values
        d += b*n.yzw*f*scale; // accumulate derivatives
        b *= 0.5;             // amplitude decrease
        f *= 1.8;             // frequency increase
    }

	return vec4( a, d );
}

float density(vec3 pos)
{
	// Magic from Shadertoy: https://www.shadertoy.com/view/MtsSRf
	float h = 0.0;
	vec2 q = pos.xz*0.5;

    // float s = 0.5;
    // for(int i=0; i<4; i++) // NOTE: Has to be i < 1 for the Terrain::Density() function to match
    // {
    //     h -= s*cosNoise(q); 
    //     q = m2*q*0.85; 
    //     q += vec2(2.41,8.13);
    //     s *= 0.48 + 0.2*h;
    // }
    // h *= 10500.0;

	float density = -pos.y;// + h;

	// density = max(-sdTorus(pos - toOrigin(vec3(20000, 5000, 5000)), vec2(2000, 1000)), density);
	//density = max(-sdBox(pos - vec3(0), vec3(25)), density);
	// density = max(-sdSphere(pos - toOrigin(vec3(8500, 10600, 0)), 1500), density);

	//density = max(-noised(pos * 20).x + 0.37, density);
	density = max(-fbmd(pos * 10).x + 0.40, density);

	return density;
}

void main(void)
{
    float density = density(gl_GlobalInvocationID.xyz / 32.0f);
    imageStore(resultImage, ivec3(gl_GlobalInvocationID.xyz), vec4(density));
    //imageStore(resultImage, ivec3(gl_GlobalInvocationID.xyz), vec4(gl_GlobalInvocationID.z / 33.0f));
}