#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (set = 0, binding = 0) uniform isampler2D edgeTableTex;
layout (set = 0, binding = 1) uniform isampler2D triangleTableTex;
layout (set = 0, binding = 2) uniform sampler3D noiseTexture;

layout(push_constant) uniform PushConsts {
	mat4 world;
	vec4 color;
} pushConsts;

layout (set = 0, binding = 3) uniform UBO_input
{
	mat4 projection;
	mat4 view;
	vec4 offsets[8];
	vec4 color;
	float voxelSize;
	float time;
} ubo;

struct GeometryVertex
{
	vec4 pos;
	vec4 normal;
};

layout(std430, set = 0, binding = 4) buffer CounterSSBO 
{
	uint vertexCount;
} counterSSBO;

layout(std430, set = 1, binding = 0) buffer VertexSSBO 
{
	GeometryVertex vertices[];
} vertexSSBO;

const vec3 origin = vec3(256000.0f);

vec3 getOrigin()
{
	return origin;
}

vec3 toOrigin(vec3 pos)
{
	return pos + origin;
}

float sdSphere(vec3 p, float s)
{
  return length(p)-s;
}

float sdTorus(vec3 p, vec2 t)
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

float sdCone(vec3 p, vec2 c)
{
    // c must be normalized
    float q = length(p.xy);
    return dot(c,vec2(q,p.z));
}

float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float opI( float d1, float d2 )
{
    return max(d1,d2);
}

float cosNoise(vec2 pos)
{
	float amplitude = 1.0f;
	float freq = 5500.0f;
	return amplitude * (sin(pos.x/freq) + sin(pos.y / freq));
}

const mat2 m2 = mat2(1.6,-1.2,
                     1.2, 1.6);



//---------------------------------------------------------------
// value noise, and its analytical derivatives
// Reference: https://www.shadertoy.com/view/XttSz2
//---------------------------------------------------------------

float hash( float n ) { return fract(sin(n)*753.5453123); }

vec4 noised( in vec3 x )
{
    vec3 p = floor(x);
    vec3 w = fract(x);
    vec3 u = w*w*(3.0-2.0*w);
    vec3 du = 6.0*w*(1.0-w);
    
    float n = p.x + p.y*157.0 + 113.0*p.z;
    
    float a = hash(n+  0.0);
    float b = hash(n+  1.0);
    float c = hash(n+157.0);
    float d = hash(n+158.0);
    float e = hash(n+113.0);
    float f = hash(n+114.0);
    float g = hash(n+270.0);
    float h = hash(n+271.0);

    float k0 =   a;
    float k1 =   b - a;
    float k2 =   c - a;
    float k3 =   e - a;
    float k4 =   a - b - c + d;
    float k5 =   a - c - e + g;
    float k6 =   a - b - e + f;
    float k7 = - a + b + c - d + e - f - g + h;

    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, 
                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));
}

vec4 fbmd( in vec3 x )
{
    const float scale = 1.5;

    float a = 0.0;
    float b = 0.5;
	float f = 1.0;
    vec3 d = vec3(0.0);
    for( int i=0; i<4; i++ )
    {
        vec4 n = noised(f*x*scale);
        a += b*n.x;           // accumulate values
        d += b*n.yzw*f*scale; // accumulate derivatives
        b *= 0.5;             // amplitude decrease
        f *= 1.8;             // frequency increase
    }

	return vec4( a, d );
}

float density(vec3 pos)
{
	// Magic from Shadertoy: https://www.shadertoy.com/view/MtsSRf
	float h = 0.0;
	vec2 q = pos.xz*0.5;

    // float s = 0.5;
    // for(int i=0; i<4; i++) // NOTE: Has to be i < 1 for the Terrain::Density() function to match
    // {
    //     h -= s*cosNoise(q); 
    //     q = m2*q*0.85; 
    //     q += vec2(2.41,8.13);
    //     s *= 0.48 + 0.2*h;
    // }
    // h *= 10500.0;

	float density = getOrigin().y - pos.y;// + h;

	// density = max(-sdTorus(pos - toOrigin(vec3(20000, 5000, 5000)), vec2(2000, 1000)), density);
	// density = max(-sdBox(pos - toOrigin(vec3(8000, 10000, 8000)), vec3(1500)), density);
	// density = max(-sdSphere(pos - toOrigin(vec3(8500, 10600, 0)), 1500), density);

	//density = max(-noised(pos / 10000).x + 0.37, density);
	density = max(-fbmd(pos / 20000.0f).x + 0.37, density);

	density = texture(noiseTexture, vec3(pos / 200000)).r;

	return density;
}

vec3 worldCoordinate()
{
	return (pushConsts.world * vec4(gl_GlobalInvocationID.xyz * ubo.voxelSize, 1.0)).xyz;
}

float density(int corner)
{
	vec3 pos = worldCoordinate() + ubo.offsets[corner].xyz;
	return density(pos);
}

vec3 vertexInterp(float isolevel, vec3 pos1, vec3 pos2, float val1, float val2)
{
	return mix(pos1, pos2, (isolevel-val1)/(val2-val1));
}

vec3 cornerPos(vec3 pos, int corner)
{
	return pos + ubo.offsets[corner].xyz;
}

vec3 cornerPos(int corner)
{
	return gl_GlobalInvocationID.xyz * ubo.voxelSize + ubo.offsets[corner].xyz;
} 

int edgeTableValue(int cubeIndex)
{
	return texelFetch(edgeTableTex, ivec2(cubeIndex, 0), 0).r;
}

int triangleTableValue(int cubeIndex, int i)
{
	return texelFetch(triangleTableTex, ivec2(i, cubeIndex), 0).r;
}

vec3 generateNormal(vec3 pos)
{
	pos = (pushConsts.world * vec4(pos, 1.0f)).xyz;
	vec3 grad;
	float d = 1.0f / 1.0f;

	grad.x = density(pos + vec3(d, 0, 0)) - density(pos + vec3(-d, 0, 0));
	grad.y = density(pos + vec3(0, d, 0)) - density(pos + vec3(0, -d, 0));
	grad.z = density(pos + vec3(0, 0, d)) - density(pos + vec3(0, 0, -d));

	vec3 normal = -normalize(grad);
	return normal;
}

void main(void)
{	
	vec3 pos = worldCoordinate();
	float isoLevel = 0.0f;

	int cubeIndex = 0;
	for(int i = 0; i < 8; i++)
	{
		if(density(pos + ubo.offsets[i].xyz) < isoLevel)
			cubeIndex |= (1 << i);
	}

	// No interesction with the isosurface in the cube
	if(texelFetch(edgeTableTex, ivec2(cubeIndex, 0), 0).r != 0)
	{
		vec3 vertList[12];

		if((edgeTableValue(cubeIndex) & 1) != 0)
			vertList[0] = vertexInterp(isoLevel, cornerPos(0), cornerPos(1), density(0), density(1));
		if((edgeTableValue(cubeIndex) & 2) != 0)
			vertList[1] = vertexInterp(isoLevel, cornerPos(1), cornerPos(2), density(1), density(2));
		if((edgeTableValue(cubeIndex) & 4) != 0)
			vertList[2] = vertexInterp(isoLevel, cornerPos(2), cornerPos(3), density(2), density(3));
		if((edgeTableValue(cubeIndex) & 8) != 0)
			vertList[3] = vertexInterp(isoLevel, cornerPos(3), cornerPos(0), density(3), density(0));
		if((edgeTableValue(cubeIndex) & 16) != 0)
			vertList[4] = vertexInterp(isoLevel, cornerPos(4), cornerPos(5), density(4), density(5));
		if((edgeTableValue(cubeIndex) & 32) != 0)
			vertList[5] = vertexInterp(isoLevel, cornerPos(5), cornerPos(6), density(5), density(6));
		if((edgeTableValue(cubeIndex) & 64) != 0)
			vertList[6] = vertexInterp(isoLevel, cornerPos(6), cornerPos(7), density(6), density(7));
		if((edgeTableValue(cubeIndex) & 128) != 0)
			vertList[7] = vertexInterp(isoLevel, cornerPos(7), cornerPos(4), density(7), density(4));
		if((edgeTableValue(cubeIndex) & 256) != 0)
			vertList[8] = vertexInterp(isoLevel, cornerPos(0), cornerPos(4), density(0), density(4));
		if((edgeTableValue(cubeIndex) & 512) != 0)
			vertList[9] = vertexInterp(isoLevel, cornerPos(1), cornerPos(5), density(1), density(5));
		if((edgeTableValue(cubeIndex) & 1024) != 0)
			vertList[10] = vertexInterp(isoLevel, cornerPos(2), cornerPos(6), density(2), density(6));
		if((edgeTableValue(cubeIndex) & 2048) != 0)
			vertList[11] = vertexInterp(isoLevel, cornerPos(3), cornerPos(7), density(3), density(7));

		mat4 viewProjection = ubo.projection * ubo.view;
		vec3 position;
		vec3 normal;
		for(int i = 0; triangleTableValue(cubeIndex, i) != -1; i += 3)
		{
			uint index = atomicAdd(counterSSBO.vertexCount, 3);

			position = vertList[triangleTableValue(cubeIndex, i)];
			normal = generateNormal(position);
			vertexSSBO.vertices[index].pos = vec4(position, 1);
			vertexSSBO.vertices[index].normal = vec4(normal, 1);

			position = vertList[triangleTableValue(cubeIndex, i + 1)];
			normal = generateNormal(position);
			vertexSSBO.vertices[index + 1].pos = vec4(position, 1);
			vertexSSBO.vertices[index + 1].normal = vec4(normal, 1);

			position = vertList[triangleTableValue(cubeIndex, i + 2)];
			normal = generateNormal(position);
			vertexSSBO.vertices[index + 2].pos = vec4(position, 1);
			vertexSSBO.vertices[index + 2].normal = vec4(normal, 1);

			// Surface normal
			vec3 U = vertexSSBO.vertices[index + 1].pos.xyz - vertexSSBO.vertices[index].pos.xyz;
			vec3 V = vertexSSBO.vertices[index + 2].pos.xyz - vertexSSBO.vertices[index].pos.xyz;

			normal.x = U.y * V.z - U.z * V.y;
			normal.y = U.z * V.x - U.x * V.z;
			normal.z = 1;//U.x * V.y - U.y - V.x;

			//normal = vec3(normal.x);

			normal = normalize(normal);

			//vertexSSBO.vertices[index].normal = vec4(normal, 1);
			//vertexSSBO.vertices[index + 1].normal = vec4(normal, 1);
			//vertexSSBO.vertices[index + 2].normal = vec4(normal, 1);

			//atomicExchange(counterSSBO.vertexCount, gl_GlobalInvocationID .z);
			//counterSSBO.vertexCount = gl_GlobalInvocationID.x;
		}
	}
}